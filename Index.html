<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Repurposing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/wavesurfer.js@6.6.3/dist/wavesurfer.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#9D9CFF',
                    }
                }
            }
        }
    </script>
    <style>
        .timeline-item {
            cursor: grab;
        }
        .timeline-item:active {
            cursor: grabbing;
        }
        .timeline {
            scrollbar-width: thin;
        }
        .timeline::-webkit-scrollbar {
            height: 8px;
        }
        .timeline::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .timeline::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .timeline::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .dark .timeline::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        .dark .timeline::-webkit-scrollbar-thumb {
            background: #555;
        }
        .dark .timeline::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        /* Canvas animation */
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.6; }
        }
        .animate-pulse-slow {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        /* Caption marker */
        .caption-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #FFC107;
            border-radius: 50%;
            bottom: -5px;
            transform: translateX(-50%);
            z-index: 10;
            cursor: pointer;
        }
        .caption-marker.selected {
            background-color: #FF5722;
            box-shadow: 0 0 0 2px rgba(255, 87, 34, 0.5);
        }
        .captions-track {
            position: relative;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.1);
            margin-top: 8px;
            border-radius: 4px;
        }
        .dark .captions-track {
            background-color: rgba(255, 255, 255, 0.1);
        }
        /* Audio waveform */
        #waveform {
            width: 100%;
            height: 80px;
            background: rgba(0,0,0,0.05);
            border-radius: 4px;
        }
        .dark #waveform {
            background: rgba(255,255,255,0.05);
        }
        /* Slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db;
            border-radius: 4px;
            outline: none;
        }
        .dark input[type="range"] {
            background: #374151;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #5D5CDE;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #5D5CDE;
            border-radius: 50%;
            cursor: pointer;
        }
        .dark input[type="range"]::-webkit-slider-thumb {
            background: #9D9CFF;
        }
        .dark input[type="range"]::-moz-range-thumb {
            background: #9D9CFF;
        }
    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <h1 class="text-3xl font-bold text-center mb-6 text-primary">Video Repurposing Studio</h1>
        
        <!-- Main content area -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <!-- Left panel: Media library and controls -->
            <div class="lg:col-span-1 bg-gray-100 dark:bg-gray-800 rounded-lg p-4 shadow-md">
                <h2 class="text-xl font-semibold mb-4">Media Library</h2>
                
                <!-- Upload controls -->
                <div class="mb-6">
                    <div class="flex space-x-2 mb-4">
                        <button id="uploadMediaBtn" class="bg-primary hover:bg-secondary text-white px-4 py-2 rounded-md transition-colors duration-200 flex-grow">
                            <span class="flex items-center justify-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                                </svg>
                                Add Media
                            </span>
                        </button>
                        <input type="file" id="mediaInput" accept="image/*,video/*,audio/*" multiple class="hidden" />
                        <button id="clearAllBtn" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-md transition-colors duration-200">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                    
                    <div id="dragDropArea" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center transition-colors duration-200 hover:border-primary dark:hover:border-primary">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 mx-auto text-gray-400 dark:text-gray-500 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                        <p class="text-gray-500 dark:text-gray-400">Drag & drop files here or click "Add Media" button</p>
                        <p class="text-xs text-gray-400 dark:text-gray-500 mt-1">Supports images, videos, and audio files</p>
                    </div>
                </div>
                
                <!-- Video settings -->
                <div class="mb-6">
                    <h3 class="text-lg font-medium mb-3">Video Settings</h3>
                    
                    <div class="mb-4">
                        <label for="totalDuration" class="block text-sm font-medium mb-1">Total Duration (seconds)</label>
                        <div class="flex items-center">
                            <input type="number" id="totalDuration" min="1" value="30" class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                            <button id="applyDurationBtn" class="ml-2 bg-primary hover:bg-secondary text-white px-3 py-2 rounded-md transition-colors duration-200">
                                Apply
                            </button>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label for="videoResolution" class="block text-sm font-medium mb-1">Resolution</label>
                        <div class="grid grid-cols-2 gap-2">
                            <select id="videoResolution" class="rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                                <option value="1920x1080">1080p (1920×1080)</option>
                                <option value="1280x720">720p (1280×720)</option>
                                <option value="3840x2160">4K (3840×2160)</option>
                                <option value="2560x1440">1440p (2560×1440)</option>
                                <option value="custom">Custom Resolution</option>
                            </select>
                            <div id="customResolutionControls" class="hidden">
                                <div class="flex space-x-1">
                                    <input type="number" id="customWidth" placeholder="Width" min="100" max="7680" class="w-1/2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-2 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary" value="1920">
                                    <div class="flex items-center px-1">×</div>
                                    <input type="number" id="customHeight" placeholder="Height" min="100" max="4320" class="w-1/2 rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-2 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary" value="1080">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mb-4">
                        <label for="textOverlay" class="block text-sm font-medium mb-1">Text Overlay</label>
                        <input type="text" id="textOverlay" placeholder="Add text overlay..." class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium mb-2">Text Position</label>
                        <div class="grid grid-cols-3 gap-2">
                            <button data-position="top-left" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Top Left</button>
                            <button data-position="top-center" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Top</button>
                            <button data-position="top-right" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Top Right</button>
                            <button data-position="middle-left" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Left</button>
                            <button data-position="middle-center" class="text-position-btn bg-primary text-white hover:bg-secondary py-1 rounded-md transition-colors duration-200">Center</button>
                            <button data-position="middle-right" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Right</button>
                            <button data-position="bottom-left" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Bottom Left</button>
                            <button data-position="bottom-center" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Bottom</button>
                            <button data-position="bottom-right" class="text-position-btn bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-1 rounded-md transition-colors duration-200">Bottom Right</button>
                        </div>
                    </div>
                </div>
                
                <!-- Audio Settings Panel -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-lg font-medium">Audio Settings</h3>
                        <button id="addAudioBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                            </svg>
                            Add Audio
                        </button>
                    </div>
                    
                    <div id="audioEmpty" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-4 text-center">
                        <p class="text-gray-500 dark:text-gray-400 text-sm">No audio added yet</p>
                        <p class="text-xs text-gray-400 dark:text-gray-500 mt-1">Add audio files to enhance your video</p>
                    </div>
                    
                    <div id="audioEditor" class="hidden mt-4">
                        <div id="waveform" class="mb-3"></div>
                        
                        <div class="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label for="mainVolume" class="block text-sm font-medium mb-1">Master Volume</label>
                                <input type="range" id="mainVolume" min="0" max="2" step="0.1" value="1" class="w-full">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>0%</span>
                                    <span>100%</span>
                                    <span>200%</span>
                                </div>
                            </div>
                            <div>
                                <label for="voiceBoost" class="block text-sm font-medium mb-1">Voice Boost</label>
                                <input type="range" id="voiceBoost" min="0" max="1" step="0.1" value="0" class="w-full">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>Off</span>
                                    <span>Max</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <label for="noiseReduction" class="block text-sm font-medium mb-1">Noise Reduction</label>
                                <input type="range" id="noiseReduction" min="0" max="1" step="0.1" value="0" class="w-full">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>Off</span>
                                    <span>Max</span>
                                </div>
                            </div>
                            <div>
                                <label for="enhanceClarity" class="block text-sm font-medium mb-1">Enhance Clarity</label>
                                <input type="range" id="enhanceClarity" min="0" max="1" step="0.1" value="0" class="w-full">
                                <div class="flex justify-between text-xs text-gray-500 mt-1">
                                    <span>Off</span>
                                    <span>Max</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex justify-between items-center mb-2">
                            <div class="flex items-center">
                                <input type="checkbox" id="muteOriginalAudio" class="mr-2">
                                <label for="muteOriginalAudio" class="text-sm">Mute original video audio</label>
                            </div>
                            <button id="processAudioBtn" class="bg-primary hover:bg-secondary text-white px-3 py-1 rounded-md text-sm transition-colors duration-200">
                                Process Audio
                            </button>
                        </div>
                        
                        <div id="processingStatus" class="hidden mt-2 p-2 bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded-md text-sm">
                            Processing audio enhancements...
                        </div>
                        
                        <div id="enhancedAudioInfo" class="hidden mt-3">
                            <div class="text-sm font-medium mb-1">Enhanced Audio</div>
                            <div class="bg-gray-50 dark:bg-gray-700 p-2 rounded-md text-xs">
                                <div class="flex justify-between mb-1">
                                    <span>Noise Reduction:</span>
                                    <span id="noiseReductionValue">50%</span>
                                </div>
                                <div class="flex justify-between mb-1">
                                    <span>Voice Enhancement:</span>
                                    <span id="voiceEnhancementValue">60%</span>
                                </div>
                                <div class="flex justify-between">
                                    <span>Clarity Improvement:</span>
                                    <span id="clarityValue">40%</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Captions panel -->
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-lg font-medium">Captions</h3>
                        <button id="addCaptionBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-md text-sm transition-colors duration-200 flex items-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                            </svg>
                            Add Caption
                        </button>
                    </div>
                    
                    <div id="captionsEmpty" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-4 text-center">
                        <p class="text-gray-500 dark:text-gray-400 text-sm">No captions added yet</p>
                        <p class="text-xs text-gray-400 dark:text-gray-500 mt-1">Click "Add Caption" to create one</p>
                    </div>
                    
                    <div id="captionEditor" class="hidden mt-4 bg-white dark:bg-gray-700 rounded-lg p-4 border border-gray-300 dark:border-gray-600">
                        <h4 class="font-medium mb-3">Edit Caption</h4>
                        <div class="mb-3">
                            <label for="captionText" class="block text-sm font-medium mb-1">Caption Text</label>
                            <textarea id="captionText" rows="2" placeholder="Enter caption text..." class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary"></textarea>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <div>
                                <label for="captionStartTime" class="block text-sm font-medium mb-1">Start Time (seconds)</label>
                                <input type="number" id="captionStartTime" min="0" step="0.1" class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                            </div>
                            <div>
                                <label for="captionDuration" class="block text-sm font-medium mb-1">Duration (seconds)</label>
                                <input type="number" id="captionDuration" min="0.1" step="0.1" value="2" class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <div>
                                <label for="captionColor" class="block text-sm font-medium mb-1">Text Color</label>
                                <div class="flex">
                                    <input type="color" id="captionColor" value="#ffffff" class="h-10 flex-grow rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700">
                                </div>
                            </div>
                            <div>
                                <label for="captionSize" class="block text-sm font-medium mb-1">Text Size</label>
                                <select id="captionSize" class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                                    <option value="text-sm">Small</option>
                                    <option value="text-base" selected>Medium</option>
                                    <option value="text-lg">Large</option>
                                    <option value="text-xl">Extra Large</option>
                                </select>
                            </div>
                        </div>
                        <div class="flex justify-between">
                            <button id="deleteCaptionBtn" class="bg-red-500 hover:bg-red-600 text-white px-3 py-2 rounded-md transition-colors duration-200">
                                Delete
                            </button>
                            <button id="saveCaptionBtn" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded-md transition-colors duration-200">
                                Save
                            </button>
                        </div>
                    </div>
                    
                    <div id="captionsList" class="mt-3 max-h-40 overflow-y-auto hidden">
                        <!-- Caption items will be added here -->
                    </div>
                </div>
                
                <!-- Export button -->
                <div class="mt-6">
                    <button id="exportBtn" class="w-full bg-green-600 hover:bg-green-700 text-white py-3 rounded-md font-semibold transition-colors duration-200 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0l-4 4m4-4v12" />
                        </svg>
                        Export Video
                    </button>
                </div>
            </div>
            
            <!-- Right panel: Preview and timeline -->
            <div class="lg:col-span-2">
                <!-- Preview area -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 mb-6 shadow-md">
                    <h2 class="text-xl font-semibold mb-4">Preview</h2>
                    <div class="relative aspect-video bg-black rounded-md overflow-hidden">
                        <canvas id="previewCanvas" class="w-full h-full"></canvas>
                        <div id="previewText" class="absolute text-white text-2xl font-bold p-4 text-center" style="display: none;"></div>
                        <div id="previewCaptions" class="absolute inset-x-0 bottom-6 flex justify-center"></div>
                        <div id="previewPlaceholder" class="absolute inset-0 flex items-center justify-center bg-gray-800 animate-pulse-slow">
                            <div class="text-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16 mx-auto text-gray-400 mb-3" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                </svg>
                                <p class="text-gray-300">Add media to preview</p>
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center justify-between mt-4">
                        <button id="playPauseBtn" class="bg-primary hover:bg-secondary text-white p-2 rounded-full transition-colors duration-200" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                        </button>
                        <div class="flex-grow mx-4">
                            <input type="range" id="timelineSlider" min="0" max="100" value="0" class="w-full" disabled>
                        </div>
                        <div id="timeDisplay" class="text-sm font-mono">00:00 / 00:00</div>
                    </div>
                    <div class="flex items-center justify-between mt-2">
                        <div class="flex items-center">
                            <button id="muteBtn" class="p-2 text-gray-500 hover:text-primary transition-colors duration-200" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                                </svg>
                            </button>
                            <input type="range" id="volumeSlider" min="0" max="1" step="0.1" value="1" class="w-24 ml-1" disabled>
                        </div>
                        <div class="flex items-center">
                            <span id="currentQualityLabel" class="text-xs text-gray-500 dark:text-gray-400 mr-2">1080p</span>
                            <button id="qualitySettingsBtn" class="p-2 text-gray-500 hover:text-primary transition-colors duration-200">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Timeline area -->
                <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4 shadow-md">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-semibold">Timeline</h2>
                        <div>
                            <button id="distributeEvenlyBtn" class="text-sm bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 px-3 py-1 rounded-md transition-colors duration-200">
                                Distribute Evenly
                            </button>
                        </div>
                    </div>
                    <div id="timelineEmpty" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center">
                        <p class="text-gray-500 dark:text-gray-400">Add media to build your timeline</p>
                    </div>
                    <div id="timelineContainer" class="hidden">
                        <div class="overflow-x-auto timeline pb-2">
                            <div id="timeline" class="flex min-w-full">
                                <!-- Timeline items will be added here -->
                            </div>
                            <div id="audioTrack" class="mt-2 h-12 bg-gray-200 dark:bg-gray-700 rounded-md relative overflow-hidden">
                                <!-- Audio track visualization will be shown here -->
                                <div class="absolute inset-0 flex items-center justify-center text-xs text-gray-500 dark:text-gray-400">
                                    Audio Track
                                </div>
                            </div>
                            <div id="captionsTrack" class="captions-track mt-2">
                                <!-- Caption markers will be added here -->
                            </div>
                        </div>
                        <div class="grid grid-cols-2 gap-4 mt-4">
                            <div>
                                <label for="clipDuration" class="block text-sm font-medium mb-1">Selected Clip Duration (seconds)</label>
                                <div class="flex">
                                    <input type="number" id="clipDuration" min="0.1" step="0.1" value="5" class="w-full rounded-md border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-700 px-4 py-2 text-base focus:outline-none focus:ring-2 focus:ring-primary">
                                    <button id="applyClipDurationBtn" class="ml-2 bg-primary hover:bg-secondary text-white px-3 py-2 rounded-md transition-colors duration-200">
                                        Apply
                                    </button>
                                </div>
                            </div>
                            <div>
                                <label for="clipOrder" class="block text-sm font-medium mb-1">Move Selected Clip</label>
                                <div class="flex space-x-2">
                                    <button id="moveLeftBtn" class="flex-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-2 rounded-md transition-colors duration-200">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                                        </svg>
                                    </button>
                                    <button id="removeClipBtn" class="flex-1 bg-red-500 hover:bg-red-600 text-white py-2 rounded-md transition-colors duration-200">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                    </button>
                                    <button id="moveRightBtn" class="flex-1 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 py-2 rounded-md transition-colors duration-200">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Export Modal -->
        <div id="exportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
                <h3 class="text-xl font-semibold mb-4">Export Video</h3>
                <p class="mb-6">Your browser can't directly export videos, but we've simulated the video creation process.</p>
                
                <div class="mb-4">
                    <h4 class="font-medium mb-2">Video Summary</h4>
                    <div class="bg-gray-100 dark:bg-gray-700 p-3 rounded-md">
                        <p id="exportSummary" class="text-sm"></p>
                    </div>
                </div>
                
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="closeExportBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500 rounded-md transition-colors duration-200">
                        Close
                    </button>
                    <button id="downloadPreviewBtn" class="px-4 py-2 bg-primary hover:bg-secondary text-white rounded-md transition-colors duration-200">
                        Download Preview
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Audio Processing Modal -->
        <div id="audioProcessingModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
                <h3 class="text-xl font-semibold mb-4">Advanced Audio Processing</h3>
                <p class="mb-4">Your audio is being enhanced with AI-powered processing.</p>
                
                <div class="mb-4">
                    <div class="relative pt-1">
                        <div class="flex mb-2 items-center justify-between">
                            <div>
                                <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full bg-primary text-white">
                                    Progress
                                </span>
                            </div>
                            <div class="text-right">
                                <span id="processingProgress" class="text-xs font-semibold inline-block text-primary">
                                    30%
                                </span>
                            </div>
                        </div>
                        <div class="overflow-hidden h-2 mb-4 text-xs flex rounded bg-gray-200 dark:bg-gray-700">
                            <div id="progressBar" style="width: 30%" class="shadow-none flex flex-col text-center whitespace-nowrap text-white justify-center bg-primary"></div>
                        </div>
                    </div>
                    
                    <div id="processingSteps" class="text-sm space-y-2">
                        <div class="flex items-center">
                            <svg class="h-4 w-4 text-green-500 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="20 6 9 17 4 12"></polyline>
                            </svg>
                            <span>Analyzing audio patterns</span>
                        </div>
                        <div class="flex items-center">
                            <svg class="h-4 w-4 text-primary animate-spin mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M12 6v6l4 2"></path>
                            </svg>
                            <span>Isolating voice frequencies</span>
                        </div>
                        <div class="flex items-center text-gray-400">
                            <div class="h-4 w-4 border-2 border-gray-300 dark:border-gray-600 rounded-full mr-2"></div>
                            <span>Reducing background noise</span>
                        </div>
                        <div class="flex items-center text-gray-400">
                            <div class="h-4 w-4 border-2 border-gray-300 dark:border-gray-600 rounded-full mr-2"></div>
                            <span>Enhancing speech clarity</span>
                        </div>
                        <div class="flex items-center text-gray-400">
                            <div class="h-4 w-4 border-2 border-gray-300 dark:border-gray-600 rounded-full mr-2"></div>
                            <span>Finalizing audio output</span>
                        </div>
                    </div>
                </div>
                
                <div class="mt-4 flex justify-end">
                    <button id="cancelAudioProcessingBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-600 hover:bg-gray-400 dark:hover:bg-gray-500 rounded-md transition-colors duration-200">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Loading Modal -->
        <div id="loadingModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full text-center">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
                <h3 class="text-xl font-semibold mt-4">Processing...</h3>
                <p class="mt-2" id="loadingMessage">Please wait while we process your media files.</p>
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // App State
        const appState = {
            mediaItems: [],
            captions: [],
            audioTracks: [],
            enhancedAudio: null,
            selectedClipIndex: -1,
            selectedCaptionIndex: -1,
            selectedAudioIndex: -1,
            playing: false,
            currentTime: 0,
            totalDuration: 30, // Default 30 seconds
            textOverlay: '',
            textPosition: 'middle-center',
            animationFrame: null,
            audioContext: null,
            audioNodes: {},
            volume: 1,
            muted: false,
            audioEnhancementSettings: {
                noiseReduction: 0,
                voiceBoost: 0,
                clarity: 0,
                muteOriginal: false
            },
            resolution: {
                width: 1920,
                height: 1080
            }
        };

        // DOM Elements
        const elements = {
            uploadMediaBtn: document.getElementById('uploadMediaBtn'),
            mediaInput: document.getElementById('mediaInput'),
            dragDropArea: document.getElementById('dragDropArea'),
            clearAllBtn: document.getElementById('clearAllBtn'),
            totalDuration: document.getElementById('totalDuration'),
            applyDurationBtn: document.getElementById('applyDurationBtn'),
            textOverlay: document.getElementById('textOverlay'),
            textPositionBtns: document.querySelectorAll('.text-position-btn'),
            exportBtn: document.getElementById('exportBtn'),
            previewCanvas: document.getElementById('previewCanvas'),
            previewText: document.getElementById('previewText'),
            previewCaptions: document.getElementById('previewCaptions'),
            previewPlaceholder: document.getElementById('previewPlaceholder'),
            playPauseBtn: document.getElementById('playPauseBtn'),
            timelineSlider: document.getElementById('timelineSlider'),
            timeDisplay: document.getElementById('timeDisplay'),
            timelineEmpty: document.getElementById('timelineEmpty'),
            timelineContainer: document.getElementById('timelineContainer'),
            timeline: document.getElementById('timeline'),
            audioTrack: document.getElementById('audioTrack'),
            captionsTrack: document.getElementById('captionsTrack'),
            clipDuration: document.getElementById('clipDuration'),
            applyClipDurationBtn: document.getElementById('applyClipDurationBtn'),
            moveLeftBtn: document.getElementById('moveLeftBtn'),
            removeClipBtn: document.getElementById('removeClipBtn'),
            moveRightBtn: document.getElementById('moveRightBtn'),
            distributeEvenlyBtn: document.getElementById('distributeEvenlyBtn'),
            exportModal: document.getElementById('exportModal'),
            exportSummary: document.getElementById('exportSummary'),
            closeExportBtn: document.getElementById('closeExportBtn'),
            downloadPreviewBtn: document.getElementById('downloadPreviewBtn'),
            loadingModal: document.getElementById('loadingModal'),
            loadingMessage: document.getElementById('loadingMessage'),
            // Caption elements
            addCaptionBtn: document.getElementById('addCaptionBtn'),
            captionsEmpty: document.getElementById('captionsEmpty'),
            captionEditor: document.getElementById('captionEditor'),
            captionText: document.getElementById('captionText'),
            captionStartTime: document.getElementById('captionStartTime'),
            captionDuration: document.getElementById('captionDuration'),
            captionColor: document.getElementById('captionColor'),
            captionSize: document.getElementById('captionSize'),
            saveCaptionBtn: document.getElementById('saveCaptionBtn'),
            deleteCaptionBtn: document.getElementById('deleteCaptionBtn'),
            captionsList: document.getElementById('captionsList'),
            // Audio elements
            muteBtn: document.getElementById('muteBtn'),
            volumeSlider: document.getElementById('volumeSlider'),
            addAudioBtn: document.getElementById('addAudioBtn'),
            audioEmpty: document.getElementById('audioEmpty'),
            audioEditor: document.getElementById('audioEditor'),
            mainVolume: document.getElementById('mainVolume'),
            voiceBoost: document.getElementById('voiceBoost'),
            noiseReduction: document.getElementById('noiseReduction'),
            enhanceClarity: document.getElementById('enhanceClarity'),
            muteOriginalAudio: document.getElementById('muteOriginalAudio'),
            processAudioBtn: document.getElementById('processAudioBtn'),
            processingStatus: document.getElementById('processingStatus'),
            enhancedAudioInfo: document.getElementById('enhancedAudioInfo'),
            noiseReductionValue: document.getElementById('noiseReductionValue'),
            voiceEnhancementValue: document.getElementById('voiceEnhancementValue'),
            clarityValue: document.getElementById('clarityValue'),
            audioProcessingModal: document.getElementById('audioProcessingModal'),
            processingProgress: document.getElementById('processingProgress'),
            progressBar: document.getElementById('progressBar'),
            processingSteps: document.getElementById('processingSteps'),
            cancelAudioProcessingBtn: document.getElementById('cancelAudioProcessingBtn'),
            qualitySettingsBtn: document.getElementById('qualitySettingsBtn'),
            currentQualityLabel: document.getElementById('currentQualityLabel')
        };

        let waveform = null;
        const ctx = elements.previewCanvas.getContext('2d');

        // Set canvas dimensions
        function resizeCanvas() {
            const container = elements.previewCanvas.parentElement;
            elements.previewCanvas.width = container.clientWidth;
            elements.previewCanvas.height = container.clientHeight;
        }

        // Initialize
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Set initial value from input
            appState.totalDuration = parseFloat(elements.totalDuration.value) || 30;
            
            // Update time display
            updateTimeDisplay();
            
            // Initialize Audio Context (when user interacts)
            document.addEventListener('click', initAudioContext, { once: true });
            
            // Initialize quality selector
            updateQualityLabel();
            
            // Add event listeners
            setupEventListeners();
        }

        // Initialize Audio Context
        function initAudioContext() {
            if (!appState.audioContext) {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    appState.audioContext = new AudioContext();
                    
                    // Create main audio nodes
                    appState.audioNodes.masterGain = appState.audioContext.createGain();
                    appState.audioNodes.masterGain.connect(appState.audioContext.destination);
                    
                    console.log('Audio context initialized');
                } catch (error) {
                    console.error('Error initializing audio context:', error);
                }
            }
        }
        
        // Update quality label based on current resolution
        function updateQualityLabel() {
            const width = appState.resolution.width;
            let qualityLabel = '';
            
            if (width >= 3840) {
                qualityLabel = '4K';
            } else if (width >= 2560) {
                qualityLabel = '1440p';
            } else if (width >= 1920) {
                qualityLabel = '1080p';
            } else if (width >= 1280) {
                qualityLabel = '720p';
            } else {
                qualityLabel = 'SD';
            }
            
            elements.currentQualityLabel.textContent = qualityLabel;
        }

        // Event Listeners
        function setupEventListeners() {
            // Upload media
            elements.uploadMediaBtn.addEventListener('click', () => {
                elements.mediaInput.click();
            });
            
            elements.mediaInput.addEventListener('change', handleFileSelect);
            
            // Drag and drop
            elements.dragDropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.dragDropArea.classList.add('border-primary');
            });
            
            elements.dragDropArea.addEventListener('dragleave', () => {
                elements.dragDropArea.classList.remove('border-primary');
            });
            
            elements.dragDropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.dragDropArea.classList.remove('border-primary');
                
                if (e.dataTransfer.files.length > 0) {
                    handleFiles(e.dataTransfer.files);
                }
            });
            
            // Clear all
            elements.clearAllBtn.addEventListener('click', clearAllMedia);
            
            // Resolution control
            const videoResolution = document.getElementById('videoResolution');
            const customResolutionControls = document.getElementById('customResolutionControls');
            const customWidth = document.getElementById('customWidth');
            const customHeight = document.getElementById('customHeight');
            
            videoResolution.addEventListener('change', () => {
                const value = videoResolution.value;
                
                if (value === 'custom') {
                    customResolutionControls.style.display = 'block';
                    appState.resolution.width = parseInt(customWidth.value);
                    appState.resolution.height = parseInt(customHeight.value);
                } else {
                    customResolutionControls.style.display = 'none';
                    const dimensions = value.split('x');
                    appState.resolution.width = parseInt(dimensions[0]);
                    appState.resolution.height = parseInt(dimensions[1]);
                }
                
                updateQualityLabel();
            });
            
            customWidth.addEventListener('change', () => {
                if (videoResolution.value === 'custom') {
                    appState.resolution.width = parseInt(customWidth.value);
                    updateQualityLabel();
                }
            });
            
            customHeight.addEventListener('change', () => {
                if (videoResolution.value === 'custom') {
                    appState.resolution.height = parseInt(customHeight.value);
                    updateQualityLabel();
                }
            });
            
            // Apply total duration
            elements.applyDurationBtn.addEventListener('click', () => {
                const newDuration = parseFloat(elements.totalDuration.value);
                if (newDuration > 0) {
                    appState.totalDuration = newDuration;
                    updateTimelineUI();
                    updateTimeDisplay();
                    updateCaptionsTrack();
                    updateAudioTrack();
                }
            });
            
            // Text overlay
            elements.textOverlay.addEventListener('input', (e) => {
                appState.textOverlay = e.target.value;
                updateTextOverlay();
            });
            
            // Text position
            elements.textPositionBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    // Remove active class from all buttons
                    elements.textPositionBtns.forEach(b => {
                        b.classList.remove('bg-primary', 'text-white');
                        b.classList.add('bg-gray-200', 'dark:bg-gray-700');
                    });
                    
                    // Add active class to clicked button
                    btn.classList.remove('bg-gray-200', 'dark:bg-gray-700');
                    btn.classList.add('bg-primary', 'text-white');
                    
                    // Update text position
                    appState.textPosition = btn.dataset.position;
                    updateTextOverlay();
                });
            });
            
            // Play/Pause
            elements.playPauseBtn.addEventListener('click', togglePlayPause);
            
            // Timeline slider
            elements.timelineSlider.addEventListener('input', (e) => {
                const percent = parseFloat(e.target.value);
                appState.currentTime = (percent / 100) * appState.totalDuration;
                updateTimeDisplay();
                drawCurrentFrame();
                updateCaptions();
                updateAudio();
            });
            
            // Clip duration
            elements.applyClipDurationBtn.addEventListener('click', () => {
                if (appState.selectedClipIndex >= 0) {
                    const newDuration = parseFloat(elements.clipDuration.value);
                    if (newDuration > 0) {
                        appState.mediaItems[appState.selectedClipIndex].duration = newDuration;
                        updateTimelineUI();
                    }
                }
            });
            
            // Move clip left
            elements.moveLeftBtn.addEventListener('click', () => {
                if (appState.selectedClipIndex > 0) {
                    const temp = appState.mediaItems[appState.selectedClipIndex];
                    appState.mediaItems[appState.selectedClipIndex] = appState.mediaItems[appState.selectedClipIndex - 1];
                    appState.mediaItems[appState.selectedClipIndex - 1] = temp;
                    appState.selectedClipIndex--;
                    updateTimelineUI();
                }
            });
            
            // Move clip right
            elements.moveRightBtn.addEventListener('click', () => {
                if (appState.selectedClipIndex >= 0 && appState.selectedClipIndex < appState.mediaItems.length - 1) {
                    const temp = appState.mediaItems[appState.selectedClipIndex];
                    appState.mediaItems[appState.selectedClipIndex] = appState.mediaItems[appState.selectedClipIndex + 1];
                    appState.mediaItems[appState.selectedClipIndex + 1] = temp;
                    appState.selectedClipIndex++;
                    updateTimelineUI();
                }
            });
            
            // Remove clip
            elements.removeClipBtn.addEventListener('click', () => {
                if (appState.selectedClipIndex >= 0) {
                    appState.mediaItems.splice(appState.selectedClipIndex, 1);
                    appState.selectedClipIndex = -1;
                    updateTimelineUI();
                    
                    if (appState.mediaItems.length === 0) {
                        stopPlayback();
                        elements.previewPlaceholder.style.display = 'flex';
                        elements.timelineEmpty.style.display = 'block';
                        elements.timelineContainer.style.display = 'none';
                        elements.playPauseBtn.disabled = true;
                        elements.timelineSlider.disabled = true;
                        elements.muteBtn.disabled = true;
                        elements.volumeSlider.disabled = true;
                    }
                }
            });
            
            // Distribute evenly
            elements.distributeEvenlyBtn.addEventListener('click', distributeClipsDuration);
            
            // Export
            elements.exportBtn.addEventListener('click', exportVideo);
            
            // Close export modal
            elements.closeExportBtn.addEventListener('click', () => {
                elements.exportModal.style.display = 'none';
            });
            
            // Download preview
            elements.downloadPreviewBtn.addEventListener('click', downloadPreview);
            
            // Cancel audio processing
            elements.cancelAudioProcessingBtn.addEventListener('click', () => {
                elements.audioProcessingModal.style.display = 'none';
            });
            
            // Audio controls
            elements.volumeSlider.addEventListener('input', (e) => {
                appState.volume = parseFloat(e.target.value);
                updateAudio();
                updateMuteButtonIcon();
            });
            
            elements.muteBtn.addEventListener('click', () => {
                appState.muted = !appState.muted;
                updateAudio();
                updateMuteButtonIcon();
            });
            
            // Add Audio button
            elements.addAudioBtn.addEventListener('click', () => {
                // Create file input for audio files
                const audioInput = document.createElement('input');
                audioInput.type = 'file';
                audioInput.accept = 'audio/*';
                audioInput.style.display = 'none';
                
                audioInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        handleAudioFile(e.target.files[0]);
                    }
                    document.body.removeChild(audioInput);
                });
                
                document.body.appendChild(audioInput);
                audioInput.click();
            });
            
            // Process audio
            elements.processAudioBtn.addEventListener('click', processAudio);
            
            // Audio enhancement controls
            elements.mainVolume.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                if (appState.audioNodes.masterGain) {
                    appState.audioNodes.masterGain.gain.value = value;
                }
            });
            
            elements.voiceBoost.addEventListener('input', (e) => {
                appState.audioEnhancementSettings.voiceBoost = parseFloat(e.target.value);
            });
            
            elements.noiseReduction.addEventListener('input', (e) => {
                appState.audioEnhancementSettings.noiseReduction = parseFloat(e.target.value);
            });
            
            elements.enhanceClarity.addEventListener('input', (e) => {
                appState.audioEnhancementSettings.clarity = parseFloat(e.target.value);
            });
            
            elements.muteOriginalAudio.addEventListener('change', (e) => {
                appState.audioEnhancementSettings.muteOriginal = e.target.checked;
            });
            
            // Caption functionality
            elements.addCaptionBtn.addEventListener('click', () => {
                // Create a new caption at current time
                appState.selectedCaptionIndex = -1; // New caption
                elements.captionText.value = '';
                elements.captionStartTime.value = appState.currentTime.toFixed(1);
                elements.captionDuration.value = '2.0';
                elements.captionColor.value = '#ffffff';
                elements.captionSize.value = 'text-base';
                
                // Show editor
                elements.captionsEmpty.style.display = 'none';
                elements.captionEditor.style.display = 'block';
                elements.captionsList.style.display = 'block';
                
                // Focus on text input
                elements.captionText.focus();
            });
            
            // Save caption
            elements.saveCaptionBtn.addEventListener('click', saveCaption);
            
            // Delete caption
            elements.deleteCaptionBtn.addEventListener('click', () => {
                if (appState.selectedCaptionIndex >= 0) {
                    appState.captions.splice(appState.selectedCaptionIndex, 1);
                    appState.selectedCaptionIndex = -1;
                    
                    updateCaptionsList();
                    updateCaptionsTrack();
                    
                    // Hide editor if no captions
                    if (appState.captions.length === 0) {
                        elements.captionsEmpty.style.display = 'block';
                        elements.captionEditor.style.display = 'none';
                        elements.captionsList.style.display = 'none';
                    }
                }
            });
            
            // Quality settings button
            elements.qualitySettingsBtn.addEventListener('click', () => {
                const dropdown = document.getElementById('videoResolution');
                dropdown.click();
            });
        }

        // Handle file selection
        function handleFileSelect(e) {
            const files = e.target.files;
            if (files.length > 0) {
                handleFiles(files);
            }
            // Reset input
            e.target.value = '';
        }

        // Handle files
        function handleFiles(files) {
            showLoadingModal('Loading media files...');
            
            const promises = [];
            const audioFiles = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
                    const promise = loadMediaFile(file);
                    promises.push(promise);
                } else if (file.type.startsWith('audio/')) {
                    audioFiles.push(file);
                }
            }
            
            Promise.all(promises)
                .then(mediaItems => {
                    // Add new items to the list
                    appState.mediaItems = [...appState.mediaItems, ...mediaItems];
                    
                    // Update UI
                    updateTimelineUI();
                    
                    // Show timeline
                    if (appState.mediaItems.length > 0) {
                        elements.timelineEmpty.style.display = 'none';
                        elements.timelineContainer.style.display = 'block';
                        elements.previewPlaceholder.style.display = 'none';
                        elements.playPauseBtn.disabled = false;
                        elements.timelineSlider.disabled = false;
                        elements.muteBtn.disabled = false;
                        elements.volumeSlider.disabled = false;
                        
                        // Draw first frame
                        appState.currentTime = 0;
                        drawCurrentFrame();
                    }
                    
                    // Handle audio files if any
                    if (audioFiles.length > 0) {
                        handleAudioFile(audioFiles[0]);
                    } else {
                        hideLoadingModal();
                    }
                })
                .catch(error => {
                    console.error('Error loading media files:', error);
                    hideLoadingModal();
                    alert('Error loading media files. Please try again.');
                });
        }

        // Load media file (image or video)
        function loadMediaFile(file) {
            return new Promise((resolve, reject) => {
                const url = URL.createObjectURL(file);
                
                if (file.type.startsWith('image/')) {
                    const img = new Image();
                    img.onload = () => {
                        resolve({
                            file,
                            type: 'image',
                            element: img,
                            url,
                            duration: 5, // Default duration for images
                            hasAudio: false
                        });
                    };
                    img.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load image'));
                    };
                    img.src = url;
                } else if (file.type.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.preload = 'metadata';
                    video.onloadedmetadata = () => {
                        // Check if video has audio tracks
                        const hasAudio = video.mozHasAudio || 
                            Boolean(video.webkitAudioDecodedByteCount) || 
                            Boolean(video.audioTracks && video.audioTracks.length);
                        
                        resolve({
                            file,
                            type: 'video',
                            element: video,
                            url,
                            duration: video.duration,
                            hasAudio: hasAudio
                        });
                    };
                    video.onerror = () => {
                        URL.revokeObjectURL(url);
                        reject(new Error('Failed to load video'));
                    };
                    video.src = url;
                } else {
                    URL.revokeObjectURL(url);
                    reject(new Error('Unsupported file type'));
                }
            });
        }

        // Handle audio file
        function handleAudioFile(file) {
            showLoadingModal('Processing audio file...');
            
            const url = URL.createObjectURL(file);
            
            // Create audio element
            const audio = new Audio();
            audio.preload = 'metadata';
            
            audio.onloadedmetadata = () => {
                // Create waveform visualization
                initWaveform(url, file.name);
                
                // Add to audio tracks
                appState.audioTracks.push({
                    file,
                    element: audio,
                    url,
                    duration: audio.duration,
                    startTime: 0, // Default to start of video
                    volume: 1
                });
                
                // Update UI
                updateAudioUI();
                hideLoadingModal();
            };
            
            audio.onerror = () => {
                URL.revokeObjectURL(url);
                console.error('Failed to load audio:', audio.error);
                hideLoadingModal();
                alert('Error loading audio file. Please try another file.');
            };
            
            audio.src = url;
        }

        // Initialize waveform visualization
        function initWaveform(url, name) {
            // Show audio editor
            elements.audioEmpty.style.display = 'none';
            elements.audioEditor.style.display = 'block';
            
            // Destroy previous waveform if exists
            if (waveform) {
                waveform.destroy();
            }
            
            // Create new waveform
            waveform = WaveSurfer.create({
                container: '#waveform',
                waveColor: '#4f46e5',
                progressColor: '#818cf8',
                cursorColor: '#3730a3',
                barWidth: 2,
                barRadius: 3,
                cursorWidth: 1,
                height: 80,
                barGap: 2,
                responsive: true
            });
            
            // Load audio file
            waveform.load(url);
            
            // Add event listeners
            waveform.on('ready', function() {
                console.log('Waveform ready');
            });
            
            waveform.on('error', function(e) {
                console.error('Waveform error:', e);
            });
        }

        // Update audio UI
        function updateAudioUI() {
            // Show or hide audio editor based on tracks
            if (appState.audioTracks.length === 0 && !appState.enhancedAudio) {
                elements.audioEmpty.style.display = 'block';
                elements.audioEditor.style.display = 'none';
            } else {
                elements.audioEmpty.style.display = 'none';
                elements.audioEditor.style.display = 'block';
            }
            
            // Update audio track visualization
            updateAudioTrack();
        }

        // Update audio track visualization
        function updateAudioTrack() {
            elements.audioTrack.innerHTML = '';
            
            if (appState.audioTracks.length === 0 && !appState.enhancedAudio) {
                return;
            }
            
            const trackWidth = elements.timeline.scrollWidth;
            
            // Create visualization for audio tracks
            appState.audioTracks.forEach((track, index) => {
                const trackElement = document.createElement('div');
                trackElement.className = 'absolute h-full bg-blue-200 dark:bg-blue-900 opacity-70 rounded-md';
                
                // Calculate position and width
                const startPercent = (track.startTime / appState.totalDuration) * 100;
                const widthPercent = Math.min(100 - startPercent, (track.duration / appState.totalDuration) * 100);
                
                trackElement.style.left = `${startPercent}%`;
                trackElement.style.width = `${widthPercent}%`;
                
                // Add label
                const trackLabel = document.createElement('div');
                trackLabel.className = 'absolute inset-0 flex items-center justify-center text-xs text-blue-800 dark:text-blue-200 truncate px-2';
                trackLabel.textContent = track.file.name;
                
                trackElement.appendChild(trackLabel);
                elements.audioTrack.appendChild(trackElement);
            });
            
            // Add enhanced audio visualization if exists
            if (appState.enhancedAudio) {
                const enhancedTrackElement = document.createElement('div');
                enhancedTrackElement.className = 'absolute h-full bg-green-200 dark:bg-green-900 opacity-70 rounded-md';
                
                // Full width for enhanced audio
                enhancedTrackElement.style.left = '0';
                enhancedTrackElement.style.width = '100%';
                
                // Add label
                const trackLabel = document.createElement('div');
                trackLabel.className = 'absolute inset-0 flex items-center justify-center text-xs text-green-800 dark:text-green-200 truncate px-2';
                trackLabel.textContent = 'Enhanced Audio';
                
                enhancedTrackElement.appendChild(trackLabel);
                elements.audioTrack.appendChild(enhancedTrackElement);
            }
        }

        // Clear all media
        function clearAllMedia() {
            // Stop playback
            stopPlayback();
            
            // Clear media items
            appState.mediaItems.forEach(item => {
                URL.revokeObjectURL(item.url);
            });
            
            appState.mediaItems = [];
            appState.selectedClipIndex = -1;
            appState.currentTime = 0;
            
            // Clear captions
            appState.captions = [];
            appState.selectedCaptionIndex = -1;
            elements.captionsEmpty.style.display = 'block';
            elements.captionEditor.style.display = 'none';
            elements.captionsList.style.display = 'none';
            elements.captionsList.innerHTML = '';
            elements.captionsTrack.innerHTML = '';
            
            // Clear audio
            appState.audioTracks.forEach(track => {
                URL.revokeObjectURL(track.url);
            });
            appState.audioTracks = [];
            if (appState.enhancedAudio) {
                URL.revokeObjectURL(appState.enhancedAudio.url);
                appState.enhancedAudio = null;
            }
            if (waveform) {
                waveform.destroy();
                waveform = null;
            }
            elements.audioEmpty.style.display = 'block';
            elements.audioEditor.style.display = 'none';
            elements.enhancedAudioInfo.style.display = 'none';
            
            // Update UI
            elements.timelineEmpty.style.display = 'block';
            elements.timelineContainer.style.display = 'none';
            elements.timeline.innerHTML = '';
            elements.previewPlaceholder.style.display = 'flex';
            elements.playPauseBtn.disabled = true;
            elements.timelineSlider.disabled = true;
            elements.muteBtn.disabled = true;
            elements.volumeSlider.disabled = true;
            
            updateTimeDisplay();
        }

        // Update timeline UI
        function updateTimelineUI() {
            elements.timeline.innerHTML = '';
            
            let totalItemsDuration = 0;
            appState.mediaItems.forEach(item => {
                totalItemsDuration += item.duration;
            });
            
            // Scale factor to fit timeline to total duration
            const scaleFactor = appState.totalDuration / totalItemsDuration;
            
            // Create timeline items
            appState.mediaItems.forEach((item, index) => {
                const scaledDuration = item.duration * scaleFactor;
                const width = Math.max(50, scaledDuration * 30); // 30px per second, minimum 50px
                
                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item relative border-2 border-gray-300 dark:border-gray-600 rounded-md overflow-hidden transition-all duration-200';
                timelineItem.style.width = `${width}px`;
                timelineItem.style.minWidth = '50px';
                timelineItem.style.height = '80px';
                timelineItem.style.marginRight = '4px';
                
                // Add selection state
                if (index === appState.selectedClipIndex) {
                    timelineItem.classList.add('border-primary', 'dark:border-primary');
                }
                
                // Create thumbnail or preview
                const thumbnail = document.createElement('div');
                thumbnail.className = 'w-full h-full bg-gray-200 dark:bg-gray-700 flex items-center justify-center';
                
                if (item.type === 'image') {
                    const img = document.createElement('img');
                    img.src = item.url;
                    img.className = 'w-full h-full object-cover';
                    thumbnail.appendChild(img);
                } else if (item.type === 'video') {
                    const video = document.createElement('video');
                    video.src = item.url;
                    video.className = 'w-full h-full object-cover';
                    thumbnail.appendChild(video);
                    
                    // Create canvas to capture thumbnail
                    const canvas = document.createElement('canvas');
                    canvas.width = 100;
                    canvas.height = 80;
                    
                    // Load video and capture thumbnail
                    video.addEventListener('loadeddata', () => {
                        video.currentTime = 0;
                        video.addEventListener('seeked', () => {
                            canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height);
                            thumbnail.style.backgroundImage = `url(${canvas.toDataURL()})`;
                            thumbnail.style.backgroundSize = 'cover';
                            thumbnail.style.backgroundPosition = 'center';
                            video.remove();
                        }, { once: true });
                    });
                }
                
                // Add duration label
                const durationLabel = document.createElement('div');
                durationLabel.className = 'absolute bottom-0 right-0 bg-black bg-opacity-50 text-white text-xs px-1 py-0.5';
                durationLabel.textContent = formatTime(item.duration);
                
                // Add type icon
                const typeIcon = document.createElement('div');
                typeIcon.className = 'absolute top-0 left-0 bg-black bg-opacity-50 text-white text-xs p-1';
                
                if (item.type === 'image') {
                    typeIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>';
                } else if (item.type === 'video') {
                    typeIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>';
                }
                
                // Add audio indicator if video has audio
                if (item.type === 'video' && item.hasAudio) {
                    const audioIcon = document.createElement('div');
                    audioIcon.className = 'absolute top-0 right-0 bg-black bg-opacity-50 text-white text-xs p-1';
                    audioIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>';
                    timelineItem.appendChild(audioIcon);
                }
                
                // Add click event
                timelineItem.addEventListener('click', () => {
                    // Deselect previous item
                    if (appState.selectedClipIndex >= 0) {
                        const prevItem = elements.timeline.children[appState.selectedClipIndex];
                        if (prevItem) {
                            prevItem.classList.remove('border-primary', 'dark:border-primary');
                        }
                    }
                    
                    // Select this item
                    appState.selectedClipIndex = index;
                    timelineItem.classList.add('border-primary', 'dark:border-primary');
                    
                    // Update clip duration input
                    elements.clipDuration.value = item.duration;
                    
                    // Set current time to start of this clip
                    let startTime = 0;
                    for (let i = 0; i < index; i++) {
                        startTime += appState.mediaItems[i].duration * scaleFactor;
                    }
                    
                    appState.currentTime = startTime;
                    updateTimeDisplay();
                    drawCurrentFrame();
                    updateCaptions();
                    updateAudio();
                });
                
                // Append elements
                timelineItem.appendChild(thumbnail);
                timelineItem.appendChild(durationLabel);
                timelineItem.appendChild(typeIcon);
                elements.timeline.appendChild(timelineItem);
            });
            
            // Update captions track
            updateCaptionsTrack();
            
            // Update audio track
            updateAudioTrack();
            
            // Update time display
            updateTimeDisplay();
        }

        // Distribute clips duration evenly
        function distributeClipsDuration() {
            if (appState.mediaItems.length === 0) return;
            
            const durationPerClip = appState.totalDuration / appState.mediaItems.length;
            
            appState.mediaItems.forEach(item => {
                item.duration = durationPerClip;
            });
            
            updateTimelineUI();
        }

        // Toggle play/pause
        function togglePlayPause() {
            if (appState.mediaItems.length === 0) return;
            
            if (appState.playing) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        // Start playback
        function startPlayback() {
            if (appState.mediaItems.length === 0) return;
            
            // Check if we're at the end
            if (appState.currentTime >= appState.totalDuration) {
                appState.currentTime = 0;
            }
            
            // Resume audio context if suspended
            if (appState.audioContext && appState.audioContext.state === 'suspended') {
                appState.audioContext.resume();
            }
            
            appState.playing = true;
            elements.playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
            
            // Start any audio tracks at current time
            playAudioAtCurrentTime();
            
            // Start animation loop
            let lastTime = performance.now();
            function animate(now) {
                const deltaTime = (now - lastTime) / 1000; // Convert to seconds
                lastTime = now;
                
                // Update current time
                appState.currentTime += deltaTime;
                
                // Check if playback has ended
                if (appState.currentTime >= appState.totalDuration) {
                    stopPlayback();
                    appState.currentTime = 0;
                }
                
                // Update UI
                updateTimeDisplay();
                drawCurrentFrame();
                updateCaptions();
                updateAudio();
                
                // Continue animation if playing
                if (appState.playing) {
                    appState.animationFrame = requestAnimationFrame(animate);
                }
            }
            
            appState.animationFrame = requestAnimationFrame(animate);
        }

        // Stop playback
        function stopPlayback() {
            appState.playing = false;
            elements.playPauseBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>';
            
            // Stop animation frame
            if (appState.animationFrame) {
                cancelAnimationFrame(appState.animationFrame);
                appState.animationFrame = null;
            }
            
            // Pause audio tracks
            pauseAllAudio();
        }

        // Play audio at current time
        function playAudioAtCurrentTime() {
            // Pause all currently playing audio
            pauseAllAudio();
            
            // Play enhanced audio if available and not muted
            if (appState.enhancedAudio && !appState.muted) {
                const audio = appState.enhancedAudio.element;
                
                // Set current time
                audio.currentTime = appState.currentTime;
                
                // Set volume based on main volume and mute state
                audio.volume = appState.muted ? 0 : appState.volume;
                
                // Play
                audio.play().catch(err => {
                    console.error('Error playing enhanced audio:', err);
                });
            } 
            // Otherwise play original audio tracks
            else if (!appState.muted && !appState.audioEnhancementSettings.muteOriginal) {
                // Play video audio
                const currentVideoWithAudio = getCurrentVideoWithAudio();
                if (currentVideoWithAudio) {
                    // Video is already playing in the preview, its audio will play automatically
                }
                
                // Play audio tracks
                appState.audioTracks.forEach(track => {
                    const audio = track.element;
                    
                    // Check if the audio should be playing at current time
                    if (appState.currentTime >= track.startTime && 
                        appState.currentTime < track.startTime + track.duration) {
                        
                        // Set current time relative to track start
                        audio.currentTime = appState.currentTime - track.startTime;
                        
                        // Set volume
                        audio.volume = appState.volume * track.volume;
                        
                        // Play
                        audio.play().catch(err => {
                            console.error('Error playing audio track:', err);
                        });
                    }
                });
            }
        }

        // Pause all audio
        function pauseAllAudio() {
            // Pause enhanced audio
            if (appState.enhancedAudio) {
                appState.enhancedAudio.element.pause();
            }
            
            // Pause all audio tracks
            appState.audioTracks.forEach(track => {
                track.element.pause();
            });
            
            // Pause any playing videos
            appState.mediaItems.forEach(item => {
                if (item.type === 'video' && item.element) {
                    item.element.pause();
                }
            });
        }

        // Update audio based on current time
        function updateAudio() {
            if (!appState.playing) {
                return;
            }
            
            // Update waveform position if exists
            if (waveform) {
                // Calculate relative position in the waveform based on video timeline
                const relativePosition = appState.currentTime / appState.totalDuration;
                waveform.seekTo(relativePosition);
            }
            
            // Update volume for all audio elements
            updateAudioVolume();
        }

        // Update audio volume
        function updateAudioVolume() {
            const effectiveVolume = appState.muted ? 0 : appState.volume;
            
            // Update master gain node if exists
            if (appState.audioNodes.masterGain) {
                appState.audioNodes.masterGain.gain.value = effectiveVolume;
            }
            
            // Update enhanced audio volume
            if (appState.enhancedAudio) {
                appState.enhancedAudio.element.volume = effectiveVolume;
            }
            
            // Update audio tracks volume
            appState.audioTracks.forEach(track => {
                track.element.volume = effectiveVolume * track.volume;
            });
            
            // Update video elements volume
            appState.mediaItems.forEach(item => {
                if (item.type === 'video' && item.element) {
                    if (appState.enhancedAudio || appState.audioEnhancementSettings.muteOriginal) {
                        item.element.volume = 0; // Mute original audio if enhanced audio is available
                    } else {
                        item.element.volume = effectiveVolume;
                    }
                }
            });
        }

        // Get current video with audio
        function getCurrentVideoWithAudio() {
            if (appState.mediaItems.length === 0) return null;
            
            // Find which clip to show at current time
            let currentClip = null;
            let timeAccumulator = 0;
            
            let totalItemsDuration = 0;
            appState.mediaItems.forEach(item => {
                totalItemsDuration += item.duration;
            });
            
            // Scale factor to fit timeline to total duration
            const scaleFactor = appState.totalDuration / totalItemsDuration;
            
            for (let i = 0; i < appState.mediaItems.length; i++) {
                const item = appState.mediaItems[i];
                const scaledDuration = item.duration * scaleFactor;
                
                if (appState.currentTime >= timeAccumulator && appState.currentTime < timeAccumulator + scaledDuration) {
                    if (item.type === 'video' && item.hasAudio) {
                        return item;
                    }
                    break;
                }
                
                timeAccumulator += scaledDuration;
            }
            
            return null;
        }

        // Update mute button icon
        function updateMuteButtonIcon() {
            if (appState.muted || appState.volume === 0) {
                elements.muteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" /></svg>';
            } else if (appState.volume < 0.5) {
                elements.muteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072" /></svg>';
            } else {
                elements.muteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>';
            }
        }

        // Process audio with enhancements
        function processAudio() {
            if (appState.audioTracks.length === 0 && !appState.mediaItems.some(item => item.type === 'video' && item.hasAudio)) {
                alert('No audio to process. Please add an audio file or video with audio.');
                return;
            }
            
            // Show processing modal
            elements.audioProcessingModal.style.display = 'flex';
            
            // Simulate processing
            let progress = 0;
            const interval = setInterval(() => {
                progress += 5;
                elements.processingProgress.textContent = `${progress}%`;
                elements.progressBar.style.width = `${progress}%`;
                
                // Update processing steps
                const steps = elements.processingSteps.children;
                if (progress >= 20 && progress < 40) {
                    steps[1].querySelector('svg').classList.remove('animate-spin');
                    steps[1].querySelector('svg').innerHTML = '<polyline points="20 6 9 17 4 12"></polyline>';
                    steps[1].querySelector('svg').classList.add('text-green-500');
                    
                    steps[2].querySelector('div').classList.add('hidden');
                    steps[2].innerHTML = '<svg class="h-4 w-4 text-primary animate-spin mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 6v6l4 2"></path></svg><span>Reducing background noise</span>';
                    steps[2].classList.remove('text-gray-400');
                } else if (progress >= 40 && progress < 60) {
                    steps[2].querySelector('svg').classList.remove('animate-spin');
                    steps[2].querySelector('svg').innerHTML = '<polyline points="20 6 9 17 4 12"></polyline>';
                    steps[2].querySelector('svg').classList.add('text-green-500');
                    
                    steps[3].querySelector('div').classList.add('hidden');
                    steps[3].innerHTML = '<svg class="h-4 w-4 text-primary animate-spin mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 6v6l4 2"></path></svg><span>Enhancing speech clarity</span>';
                    steps[3].classList.remove('text-gray-400');
                } else if (progress >= 60 && progress < 80) {
                    steps[3].querySelector('svg').classList.remove('animate-spin');
                    steps[3].querySelector('svg').innerHTML = '<polyline points="20 6 9 17 4 12"></polyline>';
                    steps[3].querySelector('svg').classList.add('text-green-500');
                    
                    steps[4].querySelector('div').classList.add('hidden');
                    steps[4].innerHTML = '<svg class="h-4 w-4 text-primary animate-spin mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><path d="M12 6v6l4 2"></path></svg><span>Finalizing audio output</span>';
                    steps[4].classList.remove('text-gray-400');
                } else if (progress >= 100) {
                    steps[4].querySelector('svg').classList.remove('animate-spin');
                    steps[4].querySelector('svg').innerHTML = '<polyline points="20 6 9 17 4 12"></polyline>';
                    steps[4].querySelector('svg').classList.add('text-green-500');
                    
                    clearInterval(interval);
                    
                    // Hide modal after a delay
                    setTimeout(() => {
                        elements.audioProcessingModal.style.display = 'none';
                        
                        // Create enhanced audio
                        createEnhancedAudio();
                        
                        // Reset progress for next time
                        setTimeout(() => {
                            elements.processingProgress.textContent = '0%';
                            elements.progressBar.style.width = '0%';
                            
                            // Reset steps
                            elements.processingSteps.innerHTML = `
                                <div class="flex items-center">
                                    <svg class="h-4 w-4 text-green-500 mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                    <span>Analyzing audio patterns</span>
                                </div>
                                <div class="flex items-center">
                                    <svg class="h-4 w-4 text-primary animate-spin mr-2" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M12 6v6l4 2"></path>
                                    </svg>
                                    <span>Isolating voice frequencies</span>
                                </div>
                                <div class="flex items-center text-gray-400">
                                    <div class="h-4 w-4 border-2 border-gray-300 dark:border-gray-600 rounded-full mr-2"></div>
                                    <span>Reducing background noise</span>
                                </div>
                                <div class="flex items-center text-gray-400">
                                    <div class="h-4 w-4 border-2 border-gray-300 dark:border-gray-600 rounded-full mr-2"></div>
                                    <span>Enhancing speech clarity</span>
                                </div>
                                <div class="flex items-center text-gray-400">
                                    <div class="h-4 w-4 border-2 border-gray-300 dark:border-gray-600 rounded-full mr-2"></div>
                                    <span>Finalizing audio output</span>
                                </div>
                            `;
                        }, 500);
                    }, 1000);
                }
            }, 100);
        }

        // Create enhanced audio
        function createEnhancedAudio() {
            // Get settings
            const noiseReduction = appState.audioEnhancementSettings.noiseReduction;
            const voiceBoost = appState.audioEnhancementSettings.voiceBoost;
            const clarity = appState.audioEnhancementSettings.clarity;
            
            // In a real application, we would apply audio filters here
            // For this demo, we'll simulate by creating a copy of an existing audio track
            let sourceAudio = null;
            
            // Try to find a video with audio first
            const videoWithAudio = appState.mediaItems.find(item => item.type === 'video' && item.hasAudio);
            if (videoWithAudio) {
                sourceAudio = videoWithAudio.element;
            } 
            // Otherwise use the first audio track if available
            else if (appState.audioTracks.length > 0) {
                sourceAudio = appState.audioTracks[0].element;
            }
            
            if (!sourceAudio) {
                console.error('No audio source found for enhancement');
                return;
            }
            
            // Create a new audio element
            const enhancedAudio = new Audio(sourceAudio.src);
            
            // Store enhanced audio
            appState.enhancedAudio = {
                element: enhancedAudio,
                url: sourceAudio.src,
                duration: sourceAudio.duration || appState.totalDuration,
                settings: {
                    noiseReduction,
                    voiceBoost,
                    clarity
                }
            };
            
            // Update audio track visualization
            updateAudioTrack();
            
            // Update enhanced audio info display
            elements.noiseReductionValue.textContent = `${Math.round(noiseReduction * 100)}%`;
            elements.voiceEnhancementValue.textContent = `${Math.round(voiceBoost * 100)}%`;
            elements.clarityValue.textContent = `${Math.round(clarity * 100)}%`;
            
            elements.enhancedAudioInfo.style.display = 'block';
            elements.processingStatus.style.display = 'none';
        }

        // Update time display
        function updateTimeDisplay() {
            elements.timeDisplay.textContent = `${formatTime(appState.currentTime)} / ${formatTime(appState.totalDuration)}`;
            elements.timelineSlider.value = (appState.currentTime / appState.totalDuration) * 100;
        }

        // Format time as mm:ss
        function formatTime(seconds) {
            seconds = Math.max(0, seconds);
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Draw current frame on canvas
        function drawCurrentFrame() {
            if (appState.mediaItems.length === 0) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, elements.previewCanvas.width, elements.previewCanvas.height);
            
            // Find which clip to show at current time
            let currentClip = null;
            let timeAccumulator = 0;
            
            let totalItemsDuration = 0;
            appState.mediaItems.forEach(item => {
                totalItemsDuration += item.duration;
            });
            
            // Scale factor to fit timeline to total duration
            const scaleFactor = appState.totalDuration / totalItemsDuration;
            
            for (let i = 0; i < appState.mediaItems.length; i++) {
                const item = appState.mediaItems[i];
                const scaledDuration = item.duration * scaleFactor;
                
                if (appState.currentTime >= timeAccumulator && appState.currentTime < timeAccumulator + scaledDuration) {
                    currentClip = {
                        item,
                        startTime: timeAccumulator,
                        itemTimeOffset: (appState.currentTime - timeAccumulator) / scaleFactor
                    };
                    break;
                }
                
                timeAccumulator += scaledDuration;
            }
            
            // Draw the current clip
            if (currentClip) {
                const item = currentClip.item;
                
                if (item.type === 'image') {
                    // Draw image
                    drawMedia(item.element);
                } else if (item.type === 'video') {
                    // Set video time and draw
                    const video = item.element;
                    video.currentTime = currentClip.itemTimeOffset;
                    
                    // If playing, ensure video is playing
                    if (appState.playing) {
                        // Set volume based on audio settings
                        if (appState.enhancedAudio || appState.audioEnhancementSettings.muteOriginal) {
                            video.volume = 0; // Mute original audio if enhanced audio is available
                        } else {
                            video.volume = appState.muted ? 0 : appState.volume;
                        }
                        
                        // Try to play video if it's paused
                        if (video.paused) {
                            video.play().catch(err => {
                                console.log('Error playing video:', err);
                            });
                        }
                    } else {
                        // Ensure video is paused if not playing
                        if (!video.paused) {
                            video.pause();
                        }
                    }
                    
                    drawMedia(video);
                }
            }
            
            // Draw text overlay
            updateTextOverlay();
        }

        // Draw media on canvas maintaining aspect ratio
        function drawMedia(element) {
            const canvas = elements.previewCanvas;
            const ctx = canvas.getContext('2d');
            
            const canvasRatio = canvas.width / canvas.height;
            const elementRatio = element.width / element.height;
            
            let drawWidth, drawHeight, x, y;
            
            if (elementRatio > canvasRatio) {
                // Element is wider than canvas (relative to height)
                drawHeight = canvas.height;
                drawWidth = element.width * (drawHeight / element.height);
                x = (canvas.width - drawWidth) / 2;
                y = 0;
            } else {
                // Element is taller than canvas (relative to width)
                drawWidth = canvas.width;
                drawHeight = element.height * (drawWidth / element.width);
                x = 0;
                y = (canvas.height - drawHeight) / 2;
            }
            
            ctx.drawImage(element, x, y, drawWidth, drawHeight);
        }

        // Update text overlay
        function updateTextOverlay() {
            // Hide text if empty
            if (!appState.textOverlay) {
                elements.previewText.style.display = 'none';
                return;
            }
            
            // Show text
            elements.previewText.style.display = 'block';
            elements.previewText.textContent = appState.textOverlay;
            
            // Position text
            const position = appState.textPosition.split('-');
            const vertical = position[0];
            const horizontal = position[1];
            
            // Reset position
            elements.previewText.style.top = 'auto';
            elements.previewText.style.right = 'auto';
            elements.previewText.style.bottom = 'auto';
            elements.previewText.style.left = 'auto';
            elements.previewText.style.transform = 'none';
            elements.previewText.style.width = 'auto';
            
            // Set vertical position
            if (vertical === 'top') {
                elements.previewText.style.top = '0';
            } else if (vertical === 'middle') {
                elements.previewText.style.top = '50%';
                elements.previewText.style.transform = elements.previewText.style.transform + ' translateY(-50%)';
            } else if (vertical === 'bottom') {
                elements.previewText.style.bottom = '0';
            }
            
            // Set horizontal position
            if (horizontal === 'left') {
                elements.previewText.style.left = '0';
            } else if (horizontal === 'center') {
                elements.previewText.style.left = '50%';
                elements.previewText.style.transform = elements.previewText.style.transform + ' translateX(-50%)';
                elements.previewText.style.width = '90%';
                elements.previewText.style.textAlign = 'center';
            } else if (horizontal === 'right') {
                elements.previewText.style.right = '0';
            }
        }

        // Save caption
        function saveCaption() {
            const text = elements.captionText.value.trim();
            if (!text) {
                alert('Please enter caption text');
                return;
            }
            
            const startTime = parseFloat(elements.captionStartTime.value);
            if (isNaN(startTime) || startTime < 0 || startTime >= appState.totalDuration) {
                alert('Please enter a valid start time');
                return;
            }
            
            const duration = parseFloat(elements.captionDuration.value);
            if (isNaN(duration) || duration <= 0) {
                alert('Please enter a valid duration');
                return;
            }
            
            // Check if this is a new caption or editing existing
            if (appState.selectedCaptionIndex >= 0) {
                // Update existing caption
                appState.captions[appState.selectedCaptionIndex] = {
                    text,
                    startTime,
                    duration,
                    color: elements.captionColor.value,
                    size: elements.captionSize.value
                };
            } else {
                // Add new caption
                appState.captions.push({
                    text,
                    startTime,
                    duration,
                    color: elements.captionColor.value,
                    size: elements.captionSize.value
                });
                
                // Sort captions by start time
                appState.captions.sort((a, b) => a.startTime - b.startTime);
                
                // Find the index of the newly added caption
                appState.selectedCaptionIndex = appState.captions.findIndex(
                    caption => caption.text === text && 
                    caption.startTime === startTime && 
                    caption.duration === duration
                );
            }
            
            // Update the UI
            updateCaptionsList();
            updateCaptionsTrack();
            updateCaptions();
        }

        // Update captions list
        function updateCaptionsList() {
            elements.captionsList.innerHTML = '';
            
            if (appState.captions.length === 0) {
                elements.captionsEmpty.style.display = 'block';
                elements.captionsList.style.display = 'none';
                return;
            }
            
            elements.captionsEmpty.style.display = 'none';
            elements.captionsList.style.display = 'block';
            
            appState.captions.forEach((caption, index) => {
                const captionItem = document.createElement('div');
                captionItem.className = 'p-2 mb-1 border border-gray-300 dark:border-gray-600 rounded-md cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors duration-200';
                
                if (index === appState.selectedCaptionIndex) {
                    captionItem.classList.add('bg-primary', 'bg-opacity-20');
                }
                
                captionItem.innerHTML = `
                    <div class="flex justify-between items-center">
                        <div class="font-medium truncate" style="color: ${caption.color};">${caption.text}</div>
                        <div class="text-xs text-gray-500">${formatTime(caption.startTime)} - ${formatTime(caption.startTime + caption.duration)}</div>
                    </div>
                `;
                
                captionItem.addEventListener('click', () => {
                    appState.selectedCaptionIndex = index;
                    
                    // Update caption editor
                    elements.captionText.value = caption.text;
                    elements.captionStartTime.value = caption.startTime.toFixed(1);
                    elements.captionDuration.value = caption.duration.toFixed(1);
                    elements.captionColor.value = caption.color;
                    elements.captionSize.value = caption.size;
                    
                    // Show editor
                    elements.captionEditor.style.display = 'block';
                    
                    // Update UI
                    updateCaptionsList();
                    
                    // Update timeline markers
                    updateCaptionsTrack();
                    
                    // Scroll to the time
                    appState.currentTime = caption.startTime;
                    updateTimeDisplay();
                    drawCurrentFrame();
                    updateCaptions();
                });
                
                elements.captionsList.appendChild(captionItem);
            });
        }

        // Update captions track in timeline
        function updateCaptionsTrack() {
            elements.captionsTrack.innerHTML = '';
            
            if (appState.captions.length === 0) {
                return;
            }
            
            // Calculate timeline width
            const timelineWidth = elements.timeline.scrollWidth;
            
            // Create caption markers
            appState.captions.forEach((caption, index) => {
                const startPercentage = (caption.startTime / appState.totalDuration) * 100;
                const leftPosition = (timelineWidth * startPercentage) / 100;
                
                const marker = document.createElement('div');
                marker.className = 'caption-marker';
                marker.style.left = `${leftPosition}px`;
                
                // Add selection state
                if (index === appState.selectedCaptionIndex) {
                    marker.classList.add('selected');
                }
                
                // Add tooltip
                marker.title = `${caption.text} (${formatTime(caption.startTime)})`;
                
                // Add click event
                marker.addEventListener('click', () => {
                    appState.selectedCaptionIndex = index;
                    
                    // Update caption editor
                    elements.captionText.value = caption.text;
                    elements.captionStartTime.value = caption.startTime.toFixed(1);
                    elements.captionDuration.value = caption.duration.toFixed(1);
                    elements.captionColor.value = caption.color;
                    elements.captionSize.value = caption.size;
                    
                    // Show editor
                    elements.captionEditor.style.display = 'block';
                    
                    // Update UI
                    updateCaptionsList();
                    updateCaptionsTrack();
                    
                    // Scroll to the time
                    appState.currentTime = caption.startTime;
                    updateTimeDisplay();
                    drawCurrentFrame();
                    updateCaptions();
                });
                
                elements.captionsTrack.appendChild(marker);
            });
        }

        // Update captions display
        function updateCaptions() {
            // Clear previous captions
            elements.previewCaptions.innerHTML = '';
            
            // Find captions that should be visible at current time
            const visibleCaptions = appState.captions.filter(
                caption => appState.currentTime >= caption.startTime && 
                appState.currentTime < caption.startTime + caption.duration
            );
            
            if (visibleCaptions.length === 0) {
                return;
            }
            
            // Create caption elements
            visibleCaptions.forEach(caption => {
                const captionElement = document.createElement('div');
                captionElement.className = `mx-2 p-2 rounded bg-black bg-opacity-60 ${caption.size}`;
                captionElement.style.color = caption.color;
                captionElement.textContent = caption.text;
                
                elements.previewCaptions.appendChild(captionElement);
            });
        }

        // Export video
        function exportVideo() {
            if (appState.mediaItems.length === 0) {
                alert('Please add media files before exporting');
                return;
            }
            
            // Prepare export summary
            let summary = `Resolution: ${appState.resolution.width}×${appState.resolution.height}\n`;
            summary += `Total Duration: ${formatTime(appState.totalDuration)}\n`;
            summary += `Media Items: ${appState.mediaItems.length}\n\n`;
            
            appState.mediaItems.forEach((item, index) => {
                summary += `${index + 1}. ${item.file.name} (${formatTime(item.duration)})`;
                if (item.type === 'video' && item.hasAudio) {
                    summary += ' [Has Audio]';
                }
                summary += '\n';
            });
            
            if (appState.audioTracks.length > 0 || appState.enhancedAudio) {
                summary += '\nAudio Tracks:\n';
                
                if (appState.enhancedAudio) {
                    summary += '- Enhanced Audio';
                    if (appState.audioEnhancementSettings.muteOriginal) {
                        summary += ' (Original audio muted)';
                    }
                    summary += '\n';
                    summary += `  • Noise Reduction: ${Math.round(appState.enhancedAudio.settings.noiseReduction * 100)}%\n`;
                    summary += `  • Voice Boost: ${Math.round(appState.enhancedAudio.settings.voiceBoost * 100)}%\n`;
                    summary += `  • Clarity: ${Math.round(appState.enhancedAudio.settings.clarity * 100)}%\n`;
                }
                
                appState.audioTracks.forEach((track, index) => {
                    summary += `- ${track.file.name} (${formatTime(track.duration)})\n`;
                });
            }
            
            if (appState.textOverlay) {
                summary += `\nText Overlay: "${appState.textOverlay}"\n`;
                summary += `Position: ${appState.textPosition.replace('-', ' ')}\n`;
            }
            
            if (appState.captions.length > 0) {
                summary += `\nCaptions: ${appState.captions.length}\n`;
                appState.captions.forEach((caption, index) => {
                    summary += `${index + 1}. "${caption.text}" (${formatTime(caption.startTime)} - ${formatTime(caption.startTime + caption.duration)})\n`;
                });
            }
            
            elements.exportSummary.textContent = summary;
            elements.exportModal.style.display = 'flex';
        }

        // Download preview
        function downloadPreview() {
            // Create a temporary canvas with the specified resolution
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = appState.resolution.width;
            tempCanvas.height = appState.resolution.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Find current clip
            let currentClip = null;
            let timeAccumulator = 0;
            
            let totalItemsDuration = 0;
            appState.mediaItems.forEach(item => {
                totalItemsDuration += item.duration;
            });
            
            // Scale factor to fit timeline to total duration
            const scaleFactor = appState.totalDuration / totalItemsDuration;
            
            for (let i = 0; i < appState.mediaItems.length; i++) {
                const item = appState.mediaItems[i];
                const scaledDuration = item.duration * scaleFactor;
                
                if (appState.currentTime >= timeAccumulator && appState.currentTime < timeAccumulator + scaledDuration) {
                    currentClip = {
                        item,
                        startTime: timeAccumulator,
                        itemTimeOffset: (appState.currentTime - timeAccumulator) / scaleFactor
                    };
                    break;
                }
                
                timeAccumulator += scaledDuration;
            }
            
            // Draw current frame at the specified resolution
            if (currentClip) {
                const item = currentClip.item;
                
                if (item.type === 'image') {
                    // Draw image maintaining aspect ratio
                    drawMediaToCanvas(item.element, tempCanvas);
                } else if (item.type === 'video') {
                    // Set video time and draw
                    const video = item.element;
                    video.currentTime = currentClip.itemTimeOffset;
                    drawMediaToCanvas(video, tempCanvas);
                }
                
                // Draw any text overlays if present
                if (appState.textOverlay) {
                    tempCtx.font = '36px Arial';
                    tempCtx.textAlign = 'center';
                    tempCtx.fillStyle = 'white';
                    tempCtx.strokeStyle = 'black';
                    tempCtx.lineWidth = 2;
                    
                    // Calculate position based on text-position setting
                    const position = appState.textPosition.split('-');
                    const vertical = position[0];
                    const horizontal = position[1];
                    
                    let x, y;
                    
                    // Set horizontal position
                    if (horizontal === 'left') {
                        x = tempCanvas.width * 0.1;
                        tempCtx.textAlign = 'left';
                    } else if (horizontal === 'center') {
                        x = tempCanvas.width / 2;
                        tempCtx.textAlign = 'center';
                    } else if (horizontal === 'right') {
                        x = tempCanvas.width * 0.9;
                        tempCtx.textAlign = 'right';
                    }
                    
                    // Set vertical position
                    if (vertical === 'top') {
                        y = tempCanvas.height * 0.1;
                    } else if (vertical === 'middle') {
                        y = tempCanvas.height / 2;
                    } else if (vertical === 'bottom') {
                        y = tempCanvas.height * 0.9;
                    }
                    
                    // Draw with stroke for better visibility
                    tempCtx.strokeText(appState.textOverlay, x, y);
                    tempCtx.fillText(appState.textOverlay, x, y);
                }
                
                // Draw any captions if visible at current time
                const visibleCaptions = appState.captions.filter(
                    caption => appState.currentTime >= caption.startTime && 
                    appState.currentTime < caption.startTime + caption.duration
                );
                
                if (visibleCaptions.length > 0) {
                    visibleCaptions.forEach(caption => {
                        let fontSize;
                        switch(caption.size) {
                            case 'text-sm': fontSize = 24; break;
                            case 'text-base': fontSize = 30; break;
                            case 'text-lg': fontSize = 36; break;
                            case 'text-xl': fontSize = 48; break;
                            default: fontSize = 30;
                        }
                        
                        tempCtx.font = `${fontSize}px Arial`;
                        tempCtx.textAlign = 'center';
                        tempCtx.fillStyle = caption.color;
                        tempCtx.strokeStyle = 'black';
                        tempCtx.lineWidth = 2;
                        
                        // Position at bottom center
                        const x = tempCanvas.width / 2;
                        const y = tempCanvas.height * 0.85;
                        
                        // Draw with stroke for better visibility
                        tempCtx.strokeText(caption.text, x, y);
                        tempCtx.fillText(caption.text, x, y);
                    });
                }
            }
            
            // Convert to data URL
            const dataURL = tempCanvas.toDataURL('image/png');
            
            // Create download link
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `video-frame-${appState.resolution.width}x${appState.resolution.height}.png`;
            link.click();
        }
        
        // Helper function to draw media on a specific canvas while maintaining aspect ratio
        function drawMediaToCanvas(element, canvas) {
            const ctx = canvas.getContext('2d');
            
            const canvasRatio = canvas.width / canvas.height;
            const elementRatio = element.width / element.height;
            
            let drawWidth, drawHeight, x, y;
            
            if (elementRatio > canvasRatio) {
                // Element is wider than canvas (relative to height)
                drawHeight = canvas.height;
                drawWidth = element.width * (drawHeight / element.height);
                x = (canvas.width - drawWidth) / 2;
                y = 0;
            } else {
                // Element is taller than canvas (relative to width)
                drawWidth = canvas.width;
                drawHeight = element.height * (drawWidth / element.width);
                x = 0;
                y = (canvas.height - drawHeight) / 2;
            }
            
            ctx.drawImage(element, x, y, drawWidth, drawHeight);
        }

        // Show loading modal
        function showLoadingModal(message) {
            elements.loadingMessage.textContent = message || 'Processing...';
            elements.loadingModal.style.display = 'flex';
        }

        // Hide loading modal
        function hideLoadingModal() {
            elements.loadingModal.style.display = 'none';
        }

        // Initialize app
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
